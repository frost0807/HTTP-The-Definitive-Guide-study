# 3장 HTTP 메시지

## 3.2 메시지의 각 부분

메시지는 이것이 어떤 메시지인지를 서술하는 시작줄, 속성은 나타내는 헤더, 데이터를 담는 본문으로 이루어져 있으며 시작줄과 헤더는 줄 바꿈으로 분리된 아스키 문자열(ASCII)이다.

### 3.2.1 메시지 문법

요청 메시지의 형식은 다음과 같다.

<메소드> <요청URL> <버전>
<헤더>

<엔티티 본문>

응답 메시지의 형식은 다음과 같다

<버전> <상태 코드> <사유 구절>
<헤더>

<엔티티 본문>

### 3.2.2 시작줄

요청 메시지의 시작줄은 무엇을 해야하는지 말해주고, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

#### 메소드

요청의 시작줄은 메소드로 시작하며 서버에게 행동을 지시한다. 요청 메시지에 따라 본문이 있는 경우도 있고 없는 경우도 있다.

![](https://i.postimg.cc/T3ZMGYtv/temp.png)

#### 상태코드

상태코드는 클라이언트에게 무엇이 일어났는지 말해준다.

![](https://i.postimg.cc/4x8vhmrj/temp.png)

#### 사유구절

사유 구절은 응답 메시지의 마지막 구성요소로, 상태 코드에 대한 설명을 제공한다.

#### 버전 번호

버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다. 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.

### 3.2.3 헤더

#### 일반헤더

요청과 응답 양쪽에 나타날 수 있음

#### 요청 헤더

요청에 대한 부가 정보를 제공

#### 응답 헤더

응답에 대한 부가 정보를 제공

#### Entity헤더

본문 크기와, 혹은 리소스 그 자체를 서술

#### 확장 헤더

명세에 정의되지 않은 새로운 헤더

<br/>

## 3.3 메소드

### 3.3.1 안전한 메소드

HTTP 요청의 결과로 서버에 어떤 작용도 없는 GET, HEAD 등을 의미한다.

### 3.3.2 GET

주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다. HTTP 1.1을 준수하기 위해서는 GET이 구현되어 있어야 한다.

### 3.3.3 HEAD

GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

HTTP 1.1 준수를 위해서는 HEAD 메소드가 구현되어있어야 한다.

### 3.3.4 PUT

PUT 메소드는 서버가 요청의 본문은 가지고 요청 URL의 명칭대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하라는 의미이다.

### 3.3.5 POST

POST 메소드는 서버에 입력 데이터를 전송하기 위해 설계되었다.

### 3.3.6 TRACE

TRACE는 클라이언트가 어떤 요청을 하면, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과하는데 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. 요청을 받은 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답으로 되돌려주며, 주로 진단을 위해 사용된다.

![](https://i.postimg.cc/qBK2Jk4X/temp.png)

#### OPTIONS

OPTIONS 메소드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.

#### DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

#### 확장 메소드

확장 메소드는 HTTP/1.1에 정의되어 있지 않은 메소드다. 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.

## 3.4 상태 코드

### 3.4.1 100-199: 정보성 상태코드

![](https://i.postimg.cc/hPWm5HFy/temp.png)

100 Continue 상태 코드는 HTTP 클라이언트가 서버에 엔티티 본문을 전송하기 전에 그 엔티티 본문을 서버가 받아들일 수 있는지 확인하려고 할 때, 그 확인 작업을 최적화 하기 위한 용도로만 사용해야 한다.

### 3.4.2 200-299: 성공 상태 코드

![](https://i.postimg.cc/KvCmfydj/temp.png)

### 3.4.3 300-399: 리다이렉션 상태 코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용대신 다른 대안 응답을 제공한다. 만약 리소스가 옮겨졌다면, 클아이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 상태 코드와 Location 헤더를 보낼 수 있다.

또한 몇몇 상태코드는 리소스에 대한 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하지 위해 사용된다.(If-Modified-Since)

![](https://i.postimg.cc/XqL60RJM/temp.png)
![](https://i.postimg.cc/7hxjXKNK/temp.png)

HTTP/1.0 기준으로는 리소스가 임시로 이동되어 추가적으로 클라이언트가 이동하길 바라는 URL을 302로 응답했다. 하지만 HTTP/1.1에 들어오면서 303을 사용하게 되었는데 혼란을 방지하기 위해 일시적인 리다이렉트는 307을 사용해야 합니다.

### 3.4.4 400-499: 클라이언트 에러 상태 코드

![](https://i.postimg.cc/BQ8Rp79n/temp.png)
![](https://i.postimg.cc/sgY6Htns/temp.png)

### 3.4.5 500-599: 서버 에러 상태 코드

![](https://i.postimg.cc/G3TZJS1h/temp.png)

## 3.5 헤더

### 3.5.1 일반 헤더

메시지의 종류에 상관없이 기본적인 정보를 제공하는 헤더다.

![](https://i.postimg.cc/NfDq52c1/temp.png)

### 3.5.2 요청 헤더

요청 메시지에서만 의미를 갖는 헤더다.

![](https://i.postimg.cc/yYbjQ7hM/temp.png)

#### Accept 관련 헤더

클라이언트는 서버에게 Accept헤더를 이용해 자신의 선호와 능력을 알려준다.

![](https://i.postimg.cc/d13Dxcjf/temp.png)

#### 조건부 요청 헤더

클라이언트가 가지고 있는 사본이 서버와 다를 때만 리소스를 전송한다든지 하는 경우에 사용한다.

![](https://i.postimg.cc/0NbbtqfB/temp.png)

#### 요청 보안 헤더

![](https://i.postimg.cc/pL5wkGjB/temp.png)

#### 프록시 요청 헤더

![](https://i.postimg.cc/4xp8mrtj/temp.png)

### 3.5.3 응답 헤더

응답 헤더는 클라이언트에게 부가 정보를 제공한다.

![](https://i.postimg.cc/Dfs5C9p0/temp.png)

#### 협상 헤더

![](https://i.postimg.cc/4474j5pm/temp.png)

#### 응답 보안 헤더

![](https://i.postimg.cc/7LddzghW/temp.png)

### 3.5.4 엔티티 헤더

![](https://i.postimg.cc/bYHVYXxM/temp.png)

#### 콘텐츠 헤더

엔티티 콘텐츠에 대한 구체적인 정보를 제공한다.

![](https://i.postimg.cc/bYHVYXxM/temp.png)

#### 엔티티 캐싱 헤더

엔티티가 언제 캐싱되어야 하는지에 대한 헤더다.

![](https://i.postimg.cc/XqGwCCZQ/temp.png)

# 4장 커넥션 관리

## 4.1 TCP 커넥션

### HTTP와 HTTPS의 프로토콜 스택

![](https://i.postimg.cc/DzNmRyyX/temp.png)

HTTP가 메시지를 전송하고자 하면, TCP는 세그먼트 단위로 데이터 스트림을 나누고, 세그먼트를 IP 패킷이라 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. 각 패킷은 IP 패킷 헤더(20바이트), TCP 세그먼트 헤더(20바이트), TCP 데이터 조각을 포함한다.

패킷은 다음과 같이 구성된다.

![](https://i.postimg.cc/Rhk7mLSw/temp.png)

TCP 커넥션은 4가지 값으로 식별된다.

<발신지 IP 주소, 발신지 PORT, 수신지 IP 주소, 수신지 PORT>

### TCP 소켓 프로그래밍

TCP 커넥션은 소켓을 통해 이루어지는데 소켓 API는 다음과 같다.

![](https://i.postimg.cc/tCrp12Zz/temp.png)
![](https://i.postimg.cc/gcVvP6Xp/temp.png)

## 4.2 TCP의 성능에 대한 고려

### HTTP 트랜잭션 지연

HTTP 트랜잭션을 지연시키는 원인은 여러 가지가 있다.

1. DNS를 통해 IP 주소를 알아내는데 걸리는 시간
2. 클라이언트가 TCP 커넥션을 서버와 맺기위해 걸리는 시간
3. HTTP 메시지가 전달되고 처리되는 시간
4. 서버가 HTTP 응답을 보내는 시간

### 성능 관련 중요 요소

- TCP 커넥션 핸드셰이크 지연 : 3-way handshake를 통해 연결을 수립하는데 시간이 걸린다.

- 확인 응답 지연 : 클라이언트가 서버에 요청을 보내고 해당 요청이 잘 전송되었는지 확인하기 위한 확인응답을 기다리는데 시간이 걸린다.

- TCP 느린 시작(slow start) : TCP가 혼잡 제어를 위해 처음에는 낮은 속도로 전송하면서 시간이 걸린다.

- 네이글 알고리즘과 TCP-NODELAY : 패킷을 전송하기 전에 효율을 위해서 작은 크기의 데이터들이 한 덩어리로 합쳐지면서 시간이 걸린다.

- TIME_WAIT의 누적과 포트 고갈 : TCP 커넥션이 닫히게 되면 해당 포트는 약 2분동안 TCP 커넥션 수립이 불가능하게 되는데 이 때문에 포트 고갈이 일어날 수 있다.

## 4.3 HTTP 커넥션 관리

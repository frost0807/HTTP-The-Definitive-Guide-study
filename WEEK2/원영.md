# 3장 HTTP 메세지

http 메시지는 앱간에 주고받은 데이터의 블록들이다.

메시지의 내용과 의미를 설명하는 텍스트 메타 정보,

선택적으로 데이터가 올 수 있다 => 데이터는 body를 의미하는듯?

인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어

- 인바운드 : 클라에서 서버 방향으로
- 아웃바운드 : 서버에서 클라 방향으로

요청, 응답에 관계없이 모든 메시지는 다운스트림으로 흐른다.

## 메시지의 구성

- 시작줄 : 이것이 어떤 메시지인지 서술
- 헤더 블록 : 속성
- 본문 : 데이터, 없을수도 있음

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열

각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.

이 줄바꿈 문자열을 CRLF 라고 쓴다.

content-length 는 본문의 크기를 말해줌

HTTP 요청 메시지 예시

```
GET /specials/saw-blade.gif HTTP/1.0
Host: www.joes-hardware.com
```

HTTP 응답 메시지 예시

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
------------------------
body
```

- 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작 ex) GET, POST, DELETE

- 요청 URL : 요청 대상이 되는 리소스를 지정하는 완전한 URL 혹은 URL의 경로 구성요소.

- 버전 : 이 메시지에서 사용중인 HTTP의 버전, 형식은
  HTTP/<메이저>.<마이너>

- 상태 코드

메시지의 시작줄의 버전번호 는 주의해야 할 사항이 몇가지 있는데

HTTP/1.1 이라는 메시지를 응답받았을때

해당 서버의 응답 프로토콜 버전이 1.1이 아니라 1.1까지 이해할 수 있다는 뜻이다.

또 버전 번호는 분수로 나뉘지 않기 때문에 두 메시지간의 버전 비교 시 HTTP/2.22 와 HTTP/2.3 은 전자가 더 크다

http 버전별 차이

1버전 이전

- http 메서드와 요청 url만 가질 뿐이면 응답 역시 엔티티만 내려줌

안전한 메서드(safe method)

get 과 head 는 안전한 메서드로 분류되는데

이는 두 메서드를 사용하는 요청이 서버에 어떤 작용도 할 수 없기 때문

## http 메서드에 대해 설명해주세요

http 메서드는 http 요청 메시지의 시작줄에 포함되는데요

서버에게 무엇을 해야 하는지를 말해주는 역할을 담당합니다.

크게 안전한 메서드와 안전하지 않은 메서드로 구분할 수 있는데요

안전한 메서드는 GET, HEAD 처럼 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미하는 메서드들 입니다.

GET과 HEAD 모두 서버에 특정 리소스를 달라고 요청하는 메서드 인데요 그 중 HEAD 메서드 같은 경우는 엔티티 본문은 제외하고 헤더만을 응답 받습니다.

PUT 메서드는 서버가 요청 본문을 가지고 새 리소스를 생성하거나 이미 존재한다면 요청 본문을 사용해 리소스를 교체합니다.

> 리소스는 일반적으로 HTML 문서, 이미지,비디오 파일, json 데이터와 같은 것들입니다.

POST는 서버에 데이터를 전송하기 위해 사용하는데요

일반적으로 HTML 폼에 입력된 데이터들을 서버에 전송할때나 서버에 데이터를 전송해서 어떤 행위를 하기 위해 사용합니다.

OPTIONS 는 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지를 물어보는 메서드입니다.

DELETE 메서드는 서버에게 지정한 리소스의 삭제를 요청합니다.

## HTTP 상태코드

- 100 ~ 199 : 정보
- 200 ~ 299 : 성공 상태 코드
- 300 ~ 399 : 리다이렉션 상태 코드 ->
  해당 요청 리소스에 대해 다른 위치를 사용하라고 알려주거나 그 리소스 내용 대신 다른 대안을 응답해준다.
  리소스가 옮겨졌으면 location 헤더를 보내 알려줄 수 있음
  301과 302 차이
- 400 ~ 499 : 클라이언트 에러 상태 코드
- 500 ~ 599 : 서버 에러 상태 코드

<br>
<br>
<br>
<br>

# 4장 커넥션 관리

- http는 어떻게 TCP 커넥션을 사옹하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

## 병렬 커넥션

여러개의 커넥션을 병렬적으로 맺어서 처리하는 커넥션 방식

단점

- 각 트랜잭션마다 커넥션을 맺고 끊기 때문에 지연 발생
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 지연 발생
- 연결할 수 있는 커넥션 수의 제한

## 지속 커넥션

http 요청을 완료한 후에도 서버가 커넥션을 계속 유지하는것,
주로 TCP의 느린시작으로 인한 지연을 피하기 위해 커넥션을 재사용하기 위해서이다.

## HTTP/1.0+ 의 Keep-Alive 커넥션

요청을 응답받은 후에도 커넥션을 유지하고 싶으면

헤더에 `Connection:Keep-Alive` 헤더를 포함하면 된다.

이 요청을 받은 서버는 그 다음 요청도 이 커넥션을 통해 받고자 한다면 응답 메시지에 같은 헤더를 포함시켜 응답한다.

응답에 `Connection:Keep-Alive` 헤더가 없으면 클라는 서버 커넥션을 끊을 것이라 추정한다.

### Keep-Alive 헤더의 옵션

- timeout : 커넥션이 얼마나 유지될지를 의미
- max : 몇개의 트랜잭션을 처리할 때까지 유지될지를 의미

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

그래서 keep-alive를 쓴다는겨 안쓴다는겨

> `Connection` 헤더는 홉 별 헤더이므로 다음 서버로 전송되어서는 안된다.

### 멍청한 프락시로 인한 keep-alive 헤더 지연

Connection: Keep-Alive 헤더를 해석하지 못하는 멍청한 프락시 서버가 클라이언트의 Keep-Alive 요청을 그대로 서버로 보내게 되면 서버는 프락시가 자기외 커넥션을 유지하는걸로 생각하고 똑같이 Keep-Alive 응답을 보내게 되고 프락시 또한 그대로 해당 응답을 클라에게 응답한다.
이때 프락시는 서버가 커넥션을 끊기를 기다리지만(Keep-Alive를 모르므로) 서버는 자신과 커넥션을 유지하기로 한 줄 알기 때문에 커넥션을 해제하지 않고
클라에서 보내는 모든 요청을 프락시는 무시하게 되면서
통신이 불가능하게 된다.

이렇게 되면 클라는 자신이나 서버가 타임아웃이 발생해서 커넥션이 끊길때까지 기다려야 한다.

> 그렇다면 프록시가 중간에 존재하는 상황에서 클라와 서버는 어떻게 커넥션을 유지할 수 있을까?

## Proxy-Connection

멍청한 프락시 문제를 해결하기 위해 확장된 헤더

> 잘 이해가 안되는게 Prox-Connection으로 보내나 그냥 Connection 으로 보내나 서버 입장에서는 어차피 커넥션 유지하라는 뜻 아닌가? 이걸로 보내는 케이스에 한해서는 프락시가 멍청한 케이스처럼 동작하지 않는다는건가 ?

## HTTP/1.1 의 지속 커넥션

HTTP/1.1에서는 별도의 설정을 하지 않는 한 모든 커넥션은 기본적으로 지속 커넥션으로 취급한다.

HTTP/1.1 클라이언트는 응답에 `Connection: close` 헤더가 없으면 커넥션을 유지하는것으로 판단한다.

커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을때만 커넥션이 유지된다 ex) `Content-Length` 포함

## 파이프라인 커넥션

무슨말인지 모르게따

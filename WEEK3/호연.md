# Chapter 5 웹서버

## Multithreading-IO, Multiplexed-IO

- Synchronous IO
  - IO 작업을 위해서 OS에게 systemcall을 요청하는데, 요청한 thread는 block이 된다. (OS-thead로 Context-switching되어 작업이 처리되기 전까지 block이 된다.)
  - syn-io 서버는 하나의 요청이 끝나서 전달되기 전까지 하나의 스레드가 대기하는 상황이 발생한다.
  - 해결방법 1 : 요청마다 thread를 할당해서 많은 요청을 처리한다.
  - 문제점 : thread가 많으면 context-switching 비용이 크다. (오버헤드가 크다)
- Asynchronous IO
  - IO 작업을 위해서 OS에게 systemcall을 요청하는데, 요청한 thread는 즉시 자신의 리턴을 받아 자신의 작업을 진행할 수 있다. (OS-thread로 전환되어 대기하지 않는다.) (ex : select, poll, epoll)
  - Async-IO 1 : block이 안 되는 대신에 데이터가 있는지 없는지 계속 확인한다. 만약 데이터가 계속 없다면 오류가 발생한다.
    - CPU 자원을 많이 소비하게 된다.
  - Async-IO 2 : 소켓에서 데이터가 있을 때, 요청 thread에게 데이터가 도착했다고 알려준다.
    - 위와 같은 IO를 multiplexing IO라고 한다.
- Tomcat NIO Connector
  - Acceptor가 요청을 PollerEvnet에 넣고 Poller가 loop를 돌면서 Woker에게 전달하는 방식
  - 기존 Blocking 대비 적은 Thread를 사용할 수 있다.
  - 요청을 처리하는 동안 idle 상태의 thread를 최대한 활용할 수 있다.

### 참고자료
[A Multithreaded Web Server](https://www.cs.carleton.edu/faculty/dmusican/cs348/webserver.html#orga32ca68)

[Writing the Server Side of a Socket](https://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html)

[입출력 다중화 (I/O Multiplexing)](https://plummmm.tistory.com/68?category=960903)

[Tomcat NIO Connector](https://velog.io/@jihoson94/BIO-NIO-Connector-in-Tomcat)

# Chapter 6 : 프록시

## 6.1 웹 중개자
- 클라이언트는 프록시가 요청을 받아도 서버에 요청하는 것처럼 대한다.
- 프록시는 웹 클라이언트이면서 웹 서버이다.
- 개인 프록시 : ISP 서비스, 브라우저 확장 기능 등으로 사용. 널리 사용하는 것은 아님
- 공용 프록시 : 대부분 프록시가 해당되는 부분
- 프록시와 게이트웨이 차이
  - 명확한 차이는 없음. 프록시도 게이트웨이처럼 동작할 수 있다.(프로토콜을 변환할 수 있다.)

## 6.2 왜 프록시를 사용하는가?
- 사용 목적 : 필터링, 접근 제어(방화벽 역할), 캐싱, 콘텐츠 라우터, 트랜스코더, 익명화, 로드 밸런싱

## 6.3 프록시는 어디에 있는가?
- reverse proxy : 클라이언트가 요청할 때 요청이 프록시를 거친다. 클라이언트는 서버의 IP를 알 수 없다. 
- forward proxy : 클라이언트에서 서버로 리소스를 요청할 때, 프록시 서버를 거쳐서 요청한다. 서버에서 받는 IP가 클라이언트의 IP가 아닌 프록시의 IP이기 때문에 서버는 누구인지 알 수 없다.

## 6.5 프록시 요청의 미묘한 특징들
- 프록시 URI는 서버 URI와 다르다.
  - 예전에는 단일 서버와 클라이언트가 통신했으나, 지금은 프록시를 거쳐서 통신하는 경우이기 때문.
- 가상 호스팅 : 하나의 서버에 여러 도메인 이름을 호스팅하는 방식.
  - 프록시 요청 시 문제가 발생할 수 있다.
    - port 정보를 포함해서 특정 호스트를 지정해서 해결
    - 완전한 URI를 갖도록 함으로써 특정 호스트가 누구인지 알 수 있다.

## 6.6 메시지 추적
- 웹 요청은 서버로 향하는 도중에 여러 프록시를 지나게 된다.
  - Via 헤더 : 메시지가 지나는 중간 노드(프록시, 게이트웨이) 정보를 나열한다.
  - Via와 게이트웨이 : 프록시로 HTTP 요청을 했는데, FTP 서버를 거치고 올 수 있다.(게이트웨이를 거침), 이 때 변경된 프로토콜 정보를 나타낸다.
- TRACE 메서드
  - 프록시가 메시지 내용을 변경할 수 있는데, TRACE 헤더로 변경과 프록시를 추적할 수 있다. (디버깅에 유용함)

## 6.8 프록시 상호운용성
- HTTP를 구현해도 여러 버전에 대해 구현되었을 수도 있다.
  - OPTIONS를 통해서 지원하는 헤더와 메서드를 확인할 수 있다.

## 질문 리스트

- apache, nginx 외 여러 프록시를 설정할 경우가 있었는지?
- 있었다면 어떤 목적으로 배치했는지?
- cloud 서비스에서 이러한 프록시를 사용할 수 있는 설정, 서비스가 있는지?
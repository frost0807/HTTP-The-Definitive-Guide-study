# 보안 HTTP

## 14.1 HTTP를 안전하게 만들기

HTTP 보안 기술을 사용함으로써 얻을 수 있는 것들

서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 통신하고 있음을 알 수 있어야 한다.

클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 통신하고 있음을 알 수 있어야 한다.

무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.

암호화 - 클라이언트와 서버는 제 3자의 도청에 대해 걱정 없이 서로 통신할 수 있어야 한다.

효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.

편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.

관리상 확장성 - 누구든 어디서든 보안 통신을 할 수 있어야 한다.

적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.

사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### 14.1.1 HTTPS

넷스케이프에서 개척하였으면 모든 주류 브라우저와 서버에서 지원한다.
HTTPS를 사용할 때, 모든 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
HTTPS는 HTTP 하위 계층에 보안 계층을 제공함으로써 동작한다.
TLS와 SSL은 매우 비슷하며 관례적으로 SSL 표현을 많이 사용한다.

## 14.2 디지털 암호학

SSL과 HTTPS에서 이용되는 암호 인코딩 기법

#### 암호

텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘

#### 키

암호의 동작을 변경하는 숫자로 된 매개변수

#### 대칭키 암호 체계

인코딩과 디코딩에 같은 키를 사용하는 알고리즘

#### 비대칭키 암호 체계

인코딩과 디코딩에 다른 키를 사용하는 알고리즘

#### 공개키 암호법

비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템

#### 디지털 서명

메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬

#### 디지털 인증서

신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 암호(cipher)

암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.
평문 혹은 텍스트 -> 암호 -> 암호문

### 14.2.2 키가 있는 암호

디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 입력할 필요가 있다.
똑같은 평문을 어떤 키로 암호화 하느냐에 따라 다른 암호문이 생성된다.
오늘날 거의 대부분 암호 알고리즘은 키를 사용한다.

### 14.2.3 디지털 암호

속도 및 기능이 좋아지면서, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다.
평문 P, 암호문 C, 인코더 E, 디코더 D, 인코딩 키 e, 디코딩 키 d
C = E(P, e)
P = D(C, d)

## 14.3 대칭키 암호법

대칭키 암호법은 인코딩을 할 때 사용하는 키가 디코딩을 할 때 사용하는 키와 같다(e = d).
대칭키 암호법에서의 키를 k라 부르자.
발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다.
발송자는 평문을 k로 암호화하여 수신자에게 발송하고, 수신자는 암호문을 수신하여 k로 복호화한다.

### 14.3.1 키 길이와 열거 공격(Enummeration Attack)

무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다.
가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유요한지에 달려있다.

### 14.3.2 공유키 발급하기

클라이언트는 서버와 암호화 된 대화를 하기 위해 클라이언트와 서버만의 개인 비밀 키를 발급해야 한다.
그러려면 비밀 키를 발급하고 그것을 기억할 방법이 필요하다.
클라이언트가 수천 개 라면 서버는 수천 개의 비밀 키를 생성하고 기억해야 할 것이다.
그 키를 관리해야 하는 사람 입장에서 이것은 지옥이다.

## 14.4 공개키 암호법

한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.
하나는 메시지 인코딩을 위한 것, 다른 하나는 메시지를 디코딩하기 위한 것
인코딩 키는 모두에게 공개되어 있지만 디코딩 키는 호스트만이 알고 있다.
서버는 자신의 인코딩 키를 공개적으로 배포했기 때문에 메시지를 서버에게 보내고자 하는 누구나 똑같고 잘 알려진 키를 사용함으로써 키가 폭발적으로 증가하는 것을 막을 수 있다.

### 14.4.1 RSA

공개키 비대칭 암호의 과제는, 해커가 아래 내용을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다.
공개키(물론 공개니까 누구나 얻을 수 있다)
가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)
스누핑이란?
스누핑(Snooping)의 Snoop은 '기웃거리다, 염탐하다'라는 뜻을 가진 단어로,
네트워크 상에서 떠도는 정보를 몰래 획득하다라는 행위를 말한다.

이 모든 요구를 만족하는 공개키 암호 체계 중 RSA 데이터 시큐리티에서 상용화된 RSA 알고리즘이 가장 유명하다.

### 14.4.2 혼성 암호 체계와 세션 키

공개 키 암호 방식의 알고리즘은 계산이 느린 경향이 있다.
그래서 대칭과 비대칭 방식을 섞은 것이 쓰인다.

## 14.5 디지털 서명

암호 체계는 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명하는 데에 이용될 수 있다.
디지털 서명은 인터넷 보안 인증서에게 중요하다.

### 14.5.1 서명은 암호 체크섬이다

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.
이들의 두 가지 이점
서명은 메시지를 작성한 저자가 누구인지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 '서명'처럼 동작한다.
서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.
디지털 서명은 보통 비대칭 공개키에 의해 생성된다.
개인 키는 오직 소유자만이 알고 있기 때문에, 저자의 개인 키는 일종의 '지문'처럼 사용된다.
해독된 디지털 서명

A는 가변 길이 메시지를 정제하여 고정된 길이의 digest로 만든다.
A는 그 Digest에, 사용자의 Secret Key를 매개변수로 하는 Signature 함수를 적용한다.
오직 그 사용자만이 Secret Key를 알고 있기 때문에, 올바른 서명 함수는 서명자가 소유자임을 보여준다.
서명 함수로 디코더 함수 D를 사용한 이유는, 그 함수가 사용자의 Secret Key와 관련되어 있기 때문이다.
한번 서명이 계산되면, A는 그것을 메시지의 끝에 덧붙이고, 메시지와 그에 대한 서명 둘 다를 B에게 전송한다.
B는 발송자가 A이며 메시지가 위조되지 않았다는 것을 증명하기 위해 서명을 검사할 수 있다.
B는 A의 Secret Key로 변형된 Signature에 Public Key를 이용한 역함수를 적용한다.
만약 풀어낸 Digest가 B가 갖고 있는 Digest와 다르다면, 메시지가 송신 중에 위조되었거나 아니면 발송자가 A의 Secret Key를 갖고있지 않는 것이다. (즉, 메시지를 쓴 것은 A가 아니다)

## 14.6 디지털 인증서

디지털 인증서(흔히 certs라 불리는)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고있다.

### 14.6.1 인증서의 내부

공식적으로 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨있다.
기본적으로 디지털 인증서에 담겨있는 정보
대상의 이름(사람, 서버, 조직 등)
유효 기간
인증서 발급자(누가 이 인증서를 보증하는가)
인증서 발급자의 디지털 서명
대상자의 공개키

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.
만약 서버가 디지털 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.
서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 서버의 이름과 호스트명
- 서버의 공개키
- CA의 이름
- CA의 서명

브라우저가 인증서를 받으면 CA를 검사한다.
해당 기관이 신뢰할만한 CA라면 브라우저는 그의 공개키를 이미 알고 있을 것이며 '디지털 서명'에서 이야기했던 바와 같이 브라우저는 그 서명을 검증할 수 있다.
브라우저가 모르는 CA라면, 브라우저는 해당 CA를 신뢰할 수 없으므로 사용자에게 CA를 신뢰하는지 확인하기 위한 대화상자를 보여준다. (CA가 사용자가 다니는 IT 부서이거나 혹은 소프트웨어 개발사일 수 있다)

## 14.7 HTTPS의 세부사항

HTTPS는 HTTP의 가장 유명한 보안 버전이다.
주류 상용 브라우저와 서버에 구현되어 있다.

### 14.7.1 HTTPS 개요

HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.
HTTP: 메시지를 TCP를 통해 보낸다.
HTTPS: 메시지를 보안 계층으로 보내 암호화한 뒤 TCP를 통해 보낸다.
HTTP 전송 단계에서의 보안

### 14.7.2 HTTPS 스킴

보안 HTTP는 선택적이기 때문에, 웹 서버로 요청할 때 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.
보안 X -> HTTP / 보안 O -> HTTPS
(웹 브라우저 등의)클라이언트는 웹 리소스를 요청받으면 URL 스킴을 검사하여 http 스킴이라면 80포트로, https 스킴이라면 443포트로 연결한다.

### 14.7.3 보안 전송 셋업

HTTPS에서의 절차는 SSL 보안 계층 때문에 HTTP보다 약간 더 복잡하다.
클라이언트는 먼저 웹 서버의 443포트로 연결하고 TCP 연결이 되고 나면, 클라이언트와 서버는 암호화를 어떤 방법으로 할지와 교환 키를 협상하면서 SSL 계층을 초기화 한다.
핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.
이 메시지는 TCP에 보내지기 전에 암호화 된다.
HTTP와 HTTPS 트랜잭션

### 14.7.4 SSL 핸드셰이크

프로토콜 버전 번호 교환
양쪽이 알고 있는 암호 선택
양쪽의 신원을 입증
채널을 암호화하기 위한 임시 세션 키 생성
SSL 핸드셰이크

### 14.7.5 서버 인증서

보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
CA에 의해 서명된 서버 인증서는, 사용자가 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.
사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있다.

# 엔터티, 인코딩, 국제화

HTTP는 콘텐츠를 나르기 위한 잘 라벨링 된 엔터티를 사용한다.

이 장에서는 엔터티 및 그와 연관된 엔터티 헤더들과 그들이 웹상의 화물을 수송하기 위해 어떤 일을 하는지에 대해 논의한다.

이 장에서 다루는 것

- HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 포맷과 동작방식
- 어떻게 HTTP까 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP가 무엇을 요구하는지
- 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들(콘텐츠의 포맷, 문자, 언어를 기술하기 위해 사용된다)
- 공간을 적게 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는, 디코딩 가능한 콘텐츠 인코딩
- 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬의 모음
- 콘텐츠의 버전 번호처럼 동작하는 검사기들(웹 애플리케이션에게 그들이 최신 콘텐츠를 가지고 있음을 확신할 수 있게 해준다). 그리고 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드들
- 중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
- 클라이언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델터 인코딩 확장
- 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는, 엔터티 본문의 체크섬

## 15.1 메시지는 컨테이너, 엔터티는 화물

HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
메시지 엔터티는 엔터티 헤더와 엔터티 본문으로 이루어짐
HTTP/1.1이 정의한 10가지 주요 엔터티 헤더 필드

#### Content-Type

엔터티에 의해 전달된 객체의 종류

#### Content-Length

전달되는 메시지의 길이나 크기

#### Content-Language

전달되는 객체와 가장 잘 대응되는 자연어

#### Content-Encoding

객체 데이터에 대해 행해진 변형(압축 등)

#### Content-Range

만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.

#### Content-MD5

엔터티 본문의 콘텐츠에 대한 체크섬

#### Last-Modified

서버에서 이 콘텐츠가 생성 혹은 수정된 날

#### Expires

이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각

#### Allow

이 리소스에 대해 어떤 메서드가 허용되는지. 예) GET과 HEAD

#### ETag

이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.

#### Cache-Control

어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다.

### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 담고 있기 때문에 엔터티 헤더는 그 데이터의 이미에 대해 설명할 필요가 있다.
Content-Type 헤더는 그 데이터를 어떻게 해석해야 하는지, Content-Encoding 헤더는 그 데이터가 압축 되었거나 추가적인 인코딩이 되었는지 말해준다.

## 15.2 Content-Length: 엔터티의 길이

Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.

### 15.2.1 잘림 검출

Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구별하지 못한다.
클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로 한다.

### 15.2.3 Content-Length와 지속 커넥션

응답이 지속 커넥션을 통해서 온 것이라면, HTTP 응답이 즉시 그 뒤를 이을 것이다.
Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

### 15.2.4 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축하기 위해 본문을 인코딩하는데, 콘텐츠가 인코딩되어 있다면 Content-Length는 인코딩된 본문의 길이를 바이트 단위로 정의한다.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1.  본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다. 이 경우 Content-Length 헤더는 부가정보에 불가하며, 실제 본문 길이를 서술하지 않는다.
2.  메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
3.  메시지가 Content-Length 헤더를 갖는다면(그리고 메시지 유형이 엔터티 본문을 허용한다면), Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다. 만약 Transfer-Encoding 헤더 필드가 있다면 Content-Length 헤더는 무시해야 한다.
4.  메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면(Content-Length 헤더로), 멀티파트 메시지의 각 부분은 각자 스스로의 크기를 정의할 것이다.

## 15.3 엔터티 요약

엔터티 본문 데이터 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며 수신자는 엔터티 변경을 잡아내기 위해 체크섬으로 기본적인 검사를 할 수 있다.

## 15.4 미디어 타입과 차셋(Charset)

Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME 타입이다. MIME 타입은 주 미디어 타입(텍스트, 이미지, 오디오 등)으로 시작해서 뒤이어 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성된다.

| 미디어 타입                   | 설명                                                                 |
| ----------------------------- | -------------------------------------------------------------------- |
| text/html                     | HTML 문서                                                            |
| text/plain                    | 플레인 텍스트 문서                                                   |
| image/gif                     | GIF 이미지                                                           |
| image/jpeg                    | JPEG 이미지                                                          |
| audio/x-wav                   | WAV 음향 데이터를 포함                                               |
| model/vrml                    | 삼차원 VRML 모델                                                     |
| application/vnd.ms-powerpoint | 마이크로소프트 파워포인트 프레젠테이션                               |
| mulipart/byteranges           | 여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위를 담고 있다. |
| message/http                  | 완전한 HTTP 메시지                                                   |

### 15.4.1 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 대표적인 예이다.
Content-Type: text/html; charset=utf-8

### 15.4.2 멀티파트 미디어 타입

MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
HTTP는 멀티파트 본문도 지원한다. 그러나 일반적으로는 폼을 채워서ㅑ 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용된다.

## 15.5 콘텐츠 인코딩

HTTP 애플리케이션은 콘텐츠를 보내기 전에 인코딩 할 수 있다.
큰 HTML 문서를 전송하기 전 압축하거나 콘쳉츠를 암호화하여 보낸다.

### 15.5.1 콘텐츠 인코딩 과정

1.  웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2.  콘텐츠 인코딩 서버(원 서버 또는 다운스트림 프락시)가 인코딩 된 메시지를 생성한다. 인코딩 된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩 된 메시지에 추가하여 수신 측 애플리케이션이 디코딩 할 수 있도록 도와준다.
3.  수신 측 애플리케이션은 인코딩 된 메시지를 받아서 디코딩 후 원본을 얻는다.
    eg. Content-Encoding: gzip
    Gzip 콘텐츠 인코더를 통해 인코딩 된 원본을 Gzip 콘텐츠 디코더를 통해 디코딩 하여 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형

HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
Content-Encoding 헤더는 표준화된 토큰 값을 이용해서, 인코딩에 사용된 알고리즘들에 대해 기술한다.
콘텐츠 인코딩 값 설명
gzip 엔터티에 GNU zip 인코딩이 적용되었음을 의미
compress 엔터티에 대해 유닉스 파일 압축 프로그램인 'compress'가 실행었엇음을 의미
deflate 엔터티가 zlib 포맷으로 압축되었음을 의미
identity 엔터티에 어떤 인코딩도 수행되지 않았음을 의미 (Content-Encoding 헤더가 없을 경우 이 값)
gzip, compress, deflate 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘
gzip이 가장 효율적이고 많이 사용됨

### 15.5.3 Accept-Encoding 헤더

서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.
Accept-Encoding 헤더를 전달하지 않는다면 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 간주한다. (= Accept-Encoding: \*)
Accept-Encoding 헤더의 몇 가지 예

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: _
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity;q=0.5, _;q=0
```

클라이언트는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있다. (min: 0.0 ~ max:1.0)

## 15.6 전송 인코딩과 청크 인코딩

이전 절에서는 메시지 본문에 적용된 가역적 변환인 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다.
예를 들어 텍스트 파일은 흔히 gzip으로 압축하지만 JPEG 파일은 gzip으로 잘 압축되지 않기 때문에 사용하지 않는다.
이 절에서는 전송 인코딩에 대해 논의하는데, 전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.
메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.
콘텐츠 인코딩된 메시지는 단지 엔터티 부분만 인코딩
전송 인코딩된 메시지는 전체 메시지를 인코딩하여 메시지 자체의 구조를 바꿈
콘텐츠 인코딩 VS 전송 인코딩

### 15.6.1 안전한 전송

역사적으로, 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.
표준화 된 전송 기반을 갖춘 HTTP는 '안전한 전송'의 초점을 다른 데에 맞추고 있다.
HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 두 가지

#### 알 수 없는 크기

몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다.
이 서버들은 그 사이즈를 알기 전에 데이터의 전송을 시작하려고 한다.
HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.

#### 보안

공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞는 방법도 있지만 SSL 같은 전송 계층 보안 방식을 주로 사용한다.

### 15.6.2 Tranfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더 두 가지

#### Transfer-Encoding

안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.

#### TE

어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용
Accept-Transfer-Encoding과 같은 의미이다.

TE 헤더 사용 예

```
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61
TE: trailers, chunked
'''
```

chunked-encoded 메시지와 메시지의 끝에 트레일러가 오는 것을 받아들일 수 있음을 서버에게 알려주기 위해 작성

Transfer-Encoding 헤더 사용 예

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
```

이 기초 헤더 뒤에 메시지 구조가 변함

### 15.6.3 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.
청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
청크 인코딩이 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성임에 주목해야 한다.

#### 청크와 지속 커넥션

지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다.
콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능할 것이다.
청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이것에 대한 해법을 제공한다.
동적으로 본문이 생성되면서, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 덩어리를 그의 크기와 함께 보낼 수 있다.
마지막 청크는 본문의 끝을 의미하기 때문에 크기가 0이다.
콘텐츠 인코딩 VS 전송 인코딩

#### 청크 인코딩된 메시지의 트레일러

다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.

- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우

트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
예로 Content-MD5 헤더가 있는데, Content-MD5 헤더는 문서가 생성되기 전에 그 문서의 MD5를 계산하기 어렵기 때문에 트레일러를 이용할 수 있다.
마지막 청크 다음에 Trailer 헤더에 나열했던 헤더들이 온다.
Trailer 헤더에 담을 수 있는 Directives

message framing headers: Transfer-Encoding, Content-Length
routhing headers: Host
request modifiers: Control-Cache, Max-Forwards, TF
authentication headers: Authorization, Set-Cookie
etc: Content-Encoding, Content-Type, Content-Range, Trailer(itself)

### 15.6.4콘텐츠 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송

### 15.6.5 전송 인코딩 규칙

- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

## 15.7 시간에 따라 바뀌는 인스턴스

같은 URL의 리소스에 대해 시간에 따라 다른 인스턴스(객체)를 응답 받을 수 있다.

## 15.8 검사기와 신선도

클라이언트가 서버로부터 처음 받은 리소스를 캐시에 저장하는데, 만료되면 서버에게 최신 사본을 요구하고 서버는 둘을 비교 한 후 변경되었으면 새로 응답

### 15.8.1 신선도

서버는 Expires와 Cache-Control 헤더를 통해 얼마나 콘텐츠를 캐시하고 있었는지, 그것이 신선하다고 할 수 있는지 정보를 제공한다.

### 15.8.2 조건부 요청과 검사기

클라이언트가 같은 리소스에 한 번 이상 접근했을 때, 우선 현재 사본이 여전히 신선한지 판별
만약 그렇지 않다면, 클라이언트는 반드시 서버로부터 최신 버전을 얻어 와야 함
리소스가 변경되지 않은 상황에서 똑같은 사본을 다시 받아오는 상황을 피하기 위해, 클라이언트는 서버에 현재 사본을 유일하게 식별할 수 있는 검사기를 명시해서 조건부 요청을 보낼 수 있음
서버는 오직 클라이언트의 사본과 다를 때만 리소스의 사본을 보낼 것이다.

## 15.9 범위 요청

HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.

```
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61
'''
```

처음 4,000바이트 이후의 부분을 요청

서버는 클라이언트에게 자신의 범위를 받아들일 수 있는지 응답에 Accpet-Ranges 헤더를 포함시켜 알려준다.
단위는 주로 바이트

```
HTTP/1.1 200 OK
Date: Fri........
Server: Apache/1.2.4
Accept-Ranges: bytes
'''
```

클라이언트의 범위 요청은 오직 클라잉너트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있다.

## 15.10 델타 인코딩

만료된 웹 페이지에 대해 새 페이지 전체를 보내는 대신 변경된 부분만 서버가 보낸다면 클라이언트는더 빨리 페이지를 얻을 수 있다.

# Chapter 14 - 보안 HTTP

## HTTPS
- http는 평문으로 전달된다. -> 중간에 민감한 정보가 노출될 가능성이 있다.
- 애플리케이션 계층과 전송 계층 사이에 보안 계층을 추가하여 https를 사용한다.
- 전송 보안을 위해서 ssl(tls)을 구현한다.

### SSL Handshake
1. 우선 서버와 클라이언트 사이에 tcp 커넥션을 수립한다. (3 way handshake)
2. client가 서버에게 client hello을 보낸다. 패킷 안에는 사용 가능한 cipher suite(SSL protocl version, 인증서 검정, 데이터 암호화 프로토콜, hash 등 포함), session id, ssl protocl version, random byte가 포함됨.
3. 서버는 클라이언트가 보낸 suite에서 ssl version, 암호화 방법 등을 정하고 chipher suite를 담아서 보낸다.
4. 이 때 서버는 자신의 인증서를 포함해서 전달한다. 인증서는 서버에서 발행한 공개키가 들어 있다.
5. 서버는 공개키를 받고 브라우저에 저장되어 있는 CA을 통해서 서버 공개키가 맞음을 확인한다.
6. 검증이 끝난 클라이언트는 공개키를 통해서 대칭키 생성, 암호화하여 서버에게 전달한다.
7. 서버는 개인키로 복호화해서 대칭키를 얻는다. 이후 대칭키를 통해서 서버와 클라이언트가 통신한다.

### SSL 서버 인증서
- 서버가 클라이언트에게 주는 인증서. https 통신을 할 때 항상 요구된다.
- 웹 서버에 대한 신용을 제 3자가 보증한다는 것이다.
- 인증서 안에 서버의 공개키와 도메인 등 다양한 정보가 담겨 있다.

## 디지털 암호학

### 대칭키
- 암호화, 복호화를 할 때 1개의 키만 사용하는 방법.
- 스트림 암호와 블록 암호가 있다.
  - 스트림 암호 : 연속적인 비트/바이트를 계속해서 입력받아, 그에 대응하는 암호화 비트/바이트를 생성하는 방식
  - 블록 암호: 정해진 한 단위(블록)를 입력받아 그에 대응하는 암호화 블록을 생성한다.

### 비대칭키 (공개키)
- 암호화와 복호화에 서로 다른 키를 사용하는 방법.
- 공개키를 통해서 누구나 메시지를 전달할 수는 있지만, 개인키를 가진 사람만 그 암호를 복호화할 수 있다.
- rsa
  - 공개키에 해당되는 개인키를 찾을 수 없도록 해야함.

### 디지털 서명
- 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 서명은 메시지를 작성한 저자가 누군인지 알려준다.
- 일반적으로 공개키 방식으로 생성된다.
- 서명이 계산되었을 때 메시지 끝에 개인키를 끝에 붙이고 메시지와 함께 전달한다.
- 수신자는 자신이 가지고 있는 개인키로 풀어낼 수 없는 서명일 경우 자신의 것이 아닌 것을 알 수 있다.

### 디지털 인증서
- 신뢰할 수 있는 조직에 의해 서명되고 검증된 신원임을 나타내는 정보
- 신뢰할 수 있는 기관에서만 발행한다.
- 대상의 이름(도메인), 유효기간, 인증서 발급자, 인증서 발급자의 디지털 서명 등을 포함한다.
- 디지털 인증서가 없을 경우 https 트랜잭션은 실패한다.

## 프록시를 통한 보안 트래픽 터널링
- 암호화된 내용은 프록시가 읽을 수 없다. -> 프록시는 바이러스나 콘텐츠 제어를 위해서 메시지 내부를 알아야 하는데 알 수가 없다.
- 클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 호스트와 포트를 프록시에게 알려준다. (암호화 전에 알려줌)
- 프록시는 클라이언트에게 받은 내용으로 서버와 클라이언트 사이에 오고 갈 수 있는 통로를 만든다. 

# Chapter 15 - 엔티티와 인코딩

## 엔티티란
- 헤더와 CRLF 다음 내용을 엔티티라고 함.
- 엔티티에 대한 정보를 나타내는 헤더들이 있다.
  - Content-Type
  - Content-Length
    - 청크 인코딩이 아닌 경우를 빼고 항상 필수적으로 담겨 있어야 한다. 지속 커넥션을 위해서 필요하다.
    - 
  - Content-language
  - Content-Encoding
  - Content-Location
  - Content-Range : 엔티티가 현재 어느 부분인지 알려준다. (length는 엔티티의 전체 길이만 나타냄)
  - Content-MD5 : 체크섬. 문서의 위치를 빠르게 알아내고 콘텐츠 중복 저장을 방지할 수 있다.

## 미디어 타입과 Charset
- 컨텐츠 타입은 MIME로 정의된다.

### multipart
- 파일을 form 형식으로 전달할 때, 여러 파일을 전달할 수 있다.
- 이 때, bondary 값을 기준으로 서버에 전달되는 파일들을 여러 개로 쪼개서 전달된다.
- 요청에 대한 응답도 multipart로 쪼개서 전달될 수 있다.
  
[multipart example](https://lng1982.tistory.com/209)


### multipart와 ftp의 차이점은?
- multipart는 http에서 데이터를 전송할 때 쪼개서 컨텐츠를 나누는 것을 뜻한다.
- ftp는 파일 전송 프로토콜이다.
- 둘 다 파일 전송에 쓰일 수 있으나, http는 Statless다. Ftp는 stateful이다. Ftp는 파일 전송을 제어할 요소가 더 많다.

## 콘텐츠 인코딩
- gzip, compress, deflate, indentity 등 인코딩 되어 전달이 가능하다.
- 인코딩이 된 경우 content-length는 인코딩된 엔티티의 길이이다.

## 전송 인코딩과 청크 인코딩
- Transfer-Encoding
  - http 1.0은 자신이 요청한 컨텐츠 사이즈를 알 수가 없기 때문에 커넥션이 끊기면 남은 데이터를 받을 수 없었다.
  - 1.1부터 persist connection을 사용해서 연결을 유지할 수 있게 됨.
  - 지속 연결을 위해서는 content-length을 알고 있어야 한다.
  - 만약 content-legnth가 엄청 큰 사이즈라서 계산이 느릴 경우, 컨텐츠가 동적으로 생성할 경우 클라이언트에게 알려주기 매우 까다롭다.(느리다)
  - 이 때, chunked 방식을 사용하는 것이 적합하다.

### 청크 인코딩
- 메시지를 일정한 크기(청크)로 쪼개서 순차적으로 전달한다.
- 청크 인코딩은 '전송 인코딩'의 한 형태이다.
- Transfer-Encoding: chunked
- content-length는 엔티티(body)의 사이즈를 나타낸다. 이 헤더가 아닌 Transfer-Encoding: chunked로 전달되면 청크 단위로 쪼개서 전달된다는 의미이다.
  - (보낸데이터크기)  
  - (데이터)
  - (보낸데이터크기)
  - (데이터)
  - 이런 식으로 전달된다. 보낸 데이터 크기가 0이면 모든 데이터를 받았음을 알 수 있다.

### 전송 인코딩 규칙
- 전송 인코딩 집합은 반드시 'chunked'를 포함해야 한다.
- 청크 인코딩으로 전송한다면 마지막 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

## 범위 요청
- 메시지를 요청했는데, 일정 부분만 받았다면 다시 요청할 때 필요한 부분만 요청할 수 있어야 한다.
- Range: (내가 받은 길이)- 를 통해서 다음 부분을 요청할 수 있다.

## 델타 인코딩
- 클라이언트가 가진 정보가 만료가 되었고 새로운 정보를 요청했다.
- 만약, 새로운 정보가 일부분만 변경이 되어서 다 전송하는 것이 손해일 경우?
- 변경된 부분만 전송하여 전송량을 최적화할 수 있다.
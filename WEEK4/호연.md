# Chapter 11 - 클라이언트 식별과 쿠키

## Http stateless
- http는 기본적으로 무상태 프로토콜이다.
- 요청마다 상태를 저장하지 않기 때문에 서버의 부담이 적다.
- 하지만 회원, 장바구니 등 상태를 저장할 필요가 있다.

## HTTP headers
- From : 사용자의 이메일 주소를 포함. 개인정보 노출이 있기 때문에 실제로 별로 안 씀.
- User-Agent : 운영체제, 접근 브라우저를 확인할 수 있다. 다운로드 시 맥용, 윈도우용 다운로드 파일 자동 제공. 크롬을 사용하지 않으면 크롬을 쓰라고 광고할 수도 있다.
- Referer : 유입 경로를 확인할 때 용이하다.
  - https://search.naver.com/search.naver?sm=top_hty&fbm=0&ie=utf8&query=ogaeng 경로로 접근할 경우 어떤 검색어로 접근했는지 알 수 있다.
  - 개인이 정하거나 브라우저에서 기본으로 정해진 것을 사용한다.

[Referer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy)

## 클라이언트 ip 주소
- HTTP 통신을 위해서 소켓을 열고 통신하기 때문에 상대방의 IP 주소를 알 수 있다.
- 하지만 IP addr != 특정할 수 있는 방문자
  - NAT (Network Address Translation) : 하나의 공인 IP 주소를 여러 대의 호스트가 사용할 수 있다. 즉, 출발지 주소가 바뀔 수가 있다.
  - DHCP : IP 주소는 동적으로 할당될 수 있다. 개인화된 정보가 잘못된 사용자에게 전달될 수 있다.

## 사용자 로그인
- 서버가 직접 개인을 파악하는 것이 아닌 사용자가 직접 식별 가능한 정보를 전달.
- http는 stateless인데, 매번 사용자가 식별 가능한 정보를 전달하는 것은 비효율적.
- 어떻게 전달할 것인가?
- 인증(authentication) : 유저가 누구이지 확인. (회원가입, 로그인)
- 인가(authorization) : 유저에 대한 권한을 허락하기. (관리자만 접근 가능한 페이지, 자기 자신의 프로필만 수정하기 등)

### 뚱뚱한 URL
- URL에 사용자를 식별하는 상태정보를 달아서 전달하기.
  - 쿼리 파라미터를 사용하는 것이 아닌 직접 경로에 상태정보를 포함시키는 방법.
- 인가를 위해서는 모든 하이퍼링크에 상태정보를 추가로 달아야 한다.
- URL이 매번 달라져서 http 캐싱을 사용할 수 없다.
- 공유할 수 없다.
- restful에서는 자원을 식별할 때 고유번호를 사용하는데, 이것은 뚱뚱한 URL?

### 쿠키
- session cookie : 사용자가 브라우저를 닫으면 삭제되는 쿠키
- persistent cookie : 사용자가 브라우저를 닫아도 디스크에 남아 있는 쿠키
- 요청을 보낼 때 URL이 아닌 헤더에 담아서 보낼 수 있다. (재사용 가능)
- 서버가 상태를 저장하는 것이 아니라서 서버 자원을 절약한다.
- scale-out 시 문제가 없다.
- referer 헤더와 함께 사용해서 사용자의 검색 기록을 추적할 수 있다.
- 클라이언트에게 저장되기 때문에 조작될 가능성이 있다. (보안에 취약함)
- 클라이언트 정보가 노출될 수 있다.

### 세션 스토리지
- 세션 저장소를 서버에 저장하고 해당 id를 쿠키로 사용자에게 전달한다.
- id를 통해서 사용자를 식별한다.
- 사용자 정보를 서버가 따로 저장해야 한다.
- scale out 시 발생하는 문제가 있다.

### session clustering (tomcat)
- 서버에 저장되어 있는 세션 정보를 다른 서버에 복사해서 서로 공유하는 방법이다.
- tomcat 설정으로 세션 클러스터링이 가능하다.

### sticky session
- 로드밸런싱에 의해 요청이 분산되어 전달된다.
- sticky session은 동일한 Ip의 요청을 동일한 서버로 전달한다.
- nginx인 경우 ip_hash를 통해서 정할 수 있다.

### global session
- sticky session은 로드 밸런싱의 효과를 가져갈 수 없다.
- session clustering은 세션 정보를 복사하는 과정 때문에 네트워크 트래픽을 잡아먹는다.
- 여러 서버가 접근 가능한 저장소에 세션 정보를 저장하면 위 설정 없이도 다른 서버에서도 세션 정보를 인식할 수 있다. (db에 저장하거나 redis, memcached와 같은 캐시에 저장한다.)

### JWT
- 세션은 서버 자원을 사용하는 단점이 있다.
- 사용자에게 인증할 수 있는 정보가 담긴 token을 암호화하여 발행하고, 인증이 필요할 때마다 서버에 token과 함께 요청하는 방식.
- 일반적으로 JWT가 널리 쓰인다.
  - HS256 : secretkey를 이용(대칭키)
  - RS256 : 개인키/공개키를 사용
- 토큰도 탈취될 가능성이 있다.
  - access token과 refresh token으로 나누어 관리한다.
  - access token은 일반적으로 요청할 때 사용한다. 하지만 유효기간이 짧다.
  - 유효기간이 만료한 토큰을 보낼 경우 refresh token을 이용해서 다시 access token을 재발급한다.
  - refresh token은 유효기간이 길게 유지하며, 재발급을 할 때만 사용한다.
  - 서버는 재발급을 위해서 Refresh token을 저장할 필요가 있다. (db나 캐시)
  - 세션과 유사한 방식이지만, 요청마다 서버가 세션 저장소를 확인할 필요가 줄어든다.

### 세션, JWT도 쿠키를 사용하는데, 결국 탈취되면 무용지물?
- HTTP Only Cookies
  - 클라이언트가 설정할 수 없는 옵션이며, 서버만 설정할 수 있다.
  - js를 통해서 쿠키를 가로챌 수 있는데, 이것을 방지하는 기능
- SSL
  - 처음부터 http 메시지를 암호화해서 전달하면 된다.

[서명 알고리즘 설명](https://erjuer.tistory.com/83)

# Chapter 12 - 인증

## HTTP 자체적인 인증관련 기능
- 위 cookie나 세션을 사용하는 것이 아닌 http 기본 인증 기능

## 기본 인증
1. 클라이언트가 get 요청을 보낸다.
2. 서버는 'WWW-Authenticate' 헤더와 함께 401 상태 정보를 응답한다.
3. 클라이언트는 'Autherization' 헤더에 인증 정보를 포함하고 서버에 전달한다.
4. 서버는 인증 정보를 확인하고 응답한다.

## 기본 인증의 보안 결함
- http는 평문으로 전달된다. Autherization 헤더에 정보를 인코딩해도 간단하게 무력화된다.
- 반드시 https를 통해서 전달해야 한다.
- 사용자가 아닌 다른 사용자가 도중에 캡처한 정보를 전달해도 http는 이를 확인하지 않는다.
- 오히려 사용자가 조작된 사이트에 들어가서 자신의 인증 정보를 전달할 수도 있다.
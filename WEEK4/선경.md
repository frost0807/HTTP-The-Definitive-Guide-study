-----

11. 클라이언트 식별과 쿠키

-----
현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶기 때문에  
개인에게 맞춰진 환영 페이지를 제공한다거나, 사용자에 맞춰 제품을 추천해주거나,  
매번 정보를 새로 입력하지 않도록 저장해주는 등의 서비스를 제공한다.  

이러한 서비스들을 제공하기 위해선 서버와 통신하는 대상들을 식별할 수 있어야 한다.  
HTTP 자체에 명시적인 식별기능은 없지만 HTTP 프로토콜 버전에 따라 기능이 제공된다.

### HTTP 헤더
#### Form 헤더
사용자의 이메일 주소를 포함하지만 악의적인 적인 서버가 이메일 주소를 모아  
스팸 메일을 발송하는 문제가 있기 때문에 Form 헤더를 보내는 브라우저는 많지 않다.
#### User-Agent 헤더
사용자가 쓰고 있는 브라우저의 이름, 버전 정보, 경우에 따라 운영체제에 대한  
정보까지 포함하여 서버에게 알려준다. 서버는 이 헤더를 사용하여 클라이언트 정보를 파악하고,  
이 정보를 바탕으로 서비스를 제공하거나 적절한 응답을 보낸다.  
예를 들어, 서버가 모바일 기기에서 요청이 왔다는 것을 파악하면,  
모바일에 최적화된 화면을 제공하거나, 모바일에서만 사용 가능한 기능을 제공할 수 있다.  

그러나 이 헤더는 사용자가 직접 변경할 수 있기 때문에 보안 상의 이유로  
신뢰할 수 없는 정보라고 할 수 있다.  
따라서 보안을 강화하기 위한 다른 방법들도 개발되고 있다.  
#### Referer 헤더
현재 페이지로 유입하게 한 웹페이지의 URL을 가리키는데  
아래와 같은 용도로 활용될 수 있다.  
- 웹 사이트 접근 통계 수집 :  
  방문자의 경로 및 유입 경로를 파악할 수 있다.
- 보안 강화 :  
  CSRF(Cross-site Request Forgery)와 같은 공격을 방지 할 수 있다.
- 컨텐츠 접근 제어 :  
  다른 웹 페이지에서 해당 페이지의 컨텐츠에 접근하는 것을 제어할 수 있다.

그러나 이 헤더는 개인정보 노출 등의 보안 문제가 발생할 수 있기 때문에  
보안 상의 이유로 Referer 헤더를 삭제하거나 조작하는 것도 가능하다.  
또한 HTTPS 프로토콜에서는 Referer 헤더가 암호화되어 전송되기 때문에  
보안에 더 강력하게 대응할 수 있다.


### 클라이언트 IP 주소
#### HTTP 클라이언트의 IP 주소를 알아내는 방법
- X-Forwarded-For 헤더 확인하기 :  
  원래 클라이언트의 IP 주소와 함께 여러 개의 IP 주소가 쉼표로 구분되어 나열될 수 있다.  
  클라이언트가 직접 조작할 수 있기 때문에 신뢰성이 떨어진다.
- Remote-Addr 헤더 확인하기 :  
  클라이언트와 서버 간에 직접 연결되는 경우에만 실제 IP 주소를 알 수 있고,  
  프록시 서버를 거치는 경우에는 프록시 서버의 IP 주소가 표시된다.
- 유닉스 시스템에서 getpeername 함수 호출하기

IP 주소를 정확하게 파악하기 위해서는 방법을 모두 확인하는 것이 좋다.

#### 단점
- 클라이언트 IP 주소는 사용자가 아니라 컴퓨터를 가리키기 때문에  
  여러 사용자가 같은 컴퓨터를 사용하는 경우 사용자를 식별하기 어렵다.
- 많은 ISP는 사용자가 로그인하면 동적으로 IP 주소를 할당하기 때문에  
  웹 서버에서는 IP 주소로 사용자를 식별할 수 없다.  
- 많은 사용자가  NAT 방화벽을 통해 인터넷을 사용하여 사용자의 실제 IP주소가  
  방화벽 IP주소로 변환된다.
- 보통 HTTP 프록시와 게이트웨이는 원 서버에 새로운 TCP 연결을 하기 때문에  
  웹 서버는 클라이언트의 IP 주소 대신 프록시 서버의 IP 주소를 본다.

### 사용자 로그인
IP 주소로 사용자를 식별하는 수동적인 방식보다  
사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.  

#### HTTP 응답코드 401
HTTP 응답코드 401 Login Required 응답 코드를 브라우저에 보내면  
브라우저는 로그인 대화상자를 보여주고, 다음 요청부터 Authorization 헤더에  
그 정보를 기술하여 보낸다.

<img src="https://iloveulhj.github.io/images/basic-auth/basic-auth2.png" width="500" height="200"/>

#### 뚱뚱한 URL
사용자의 상태 정보를 포함하고 있는 URL을 말한다.  
사용자에게 할당된 식별번호를 각 URL 뒤에 붙여서 사용자를 추적한다.
#### 문제점
- 못생긴 URL :
  새로운 사용자들에게 혼란을 준다.
- 공유하지 못하는 URL :
  특정 사용자와 세션에 대한 상태 정보를 포함하기 때문에 이 URL을 공유하면  
  개인정보를 공유하는 격이다.
- 캐시를 사용할 수 없음 :  
  URL이 달라지기 때문에 기존 캐시에 접근할 수 없다.
- 서버 부하 가중 :  
  해당 URL에 해당하는 HTML 페이지를 새로 그려야 한다.
- 이탈 :  
  링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청하여 뚱뚱한 URL에서 이탈하기 쉽다.
- 세션 간 지속성의 부재 :  
  사용자가 뚱뚱한 URL을 북마킹 하지 않는 이상 로그아웃을 하면 모든 정보를 잃는다.

### 쿠키
웹 사이트가 인터넷 사용자의 컴퓨터나 모바일 기기에 저장하는 작은 데이터 파일이다.

#### 타입
- 세션 쿠키: 사용자가 브라우저를 닫으면 삭제된다.
- 지속 쿠키: 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.  
- 
#### 동작 방식
<img src="https://2.bp.blogspot.com/-qyv2k3X-ucc/WWbByGzs7EI/AAAAAAAASjY/Z2bBoxYP5TwWti9HEgQy3KUQrmgq9gf2ACLcBGAs/w1200-h630-p-k-no-nu/32.jpg" width="500" height="200"/>

#### 세션쿠키
쿠키의 한 종류로 사용자가 웹 사이트를 방문하는 동안 생성되며,  
브라우저가 닫히면 자동으로 삭제된다.  
즉 브라우저 세션이 유지되는 동안에만 유효한 쿠키이다.  

주로 로그인 정보나 장바구니 정보와 같은 임시적인 데이터를 저장하는 데 사용된다.  
이러한 정보는 브라우저가 닫히면 더 이상 필요하지 않기 때문에  
세션 쿠키를 사용하여 임시 데이터를 저장할 수 있다.  

#### 캐시를 다루는 기본 원칙
- 캐시되지 말아야 할 문서가 있다면 표시하라
- Set-Cookie 헤더를 캐시 하는 것에 유의하라
- Cookie 헤더를 가지고 있는 요청을 주의하라

#### 쿠키 보안
쿠키는 사용자의 정보를 저장하기 때문에 보안상 매우 중요하다.  
악의적인 사용자 사용자의 정보를 악용할 수 있기 때문이다.  

쿠키 보안을 강화하기 위해 아래와 같은 방법들이 사용된다.  
- 암호화
- HttpOnly 속성
- Secure 속성
- 쿠키 만료시간 설정
- 중요한 정보를 저장하지 않기

-----

12. 기본 인증

-----
### 인증
#### HTTP의 인증요구/응답 프레임워크
HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.  

인증요구는 웹 서버에서 클라이언트에게 보안 인증을 요구하는 매커니즘으로  
이를 통해 웹 서버는 클라이언트가 특정한 자격 증명을 가지고 있는지 확인하고,  
허가된 사용자에게만 접근을 허용할 수 있다.

HTTP 인증 요구에는 Basic 인증과 Digest 인증이 있다.

#### HTTP 인증 요구 동작
1. 클라이언트가 웹 서버에 요청을 보낸다.
2. 웹 서버는 클라이언트에게 인증을 요구하는 응답을 보낸다.
3. 클라이언트는 자격 증명을 입력하여 웹 서버에 보낸다.
4. 웹 서버는 클라이언트가 제공한 자격 증명을 확인한다.
5. 자격 증명이 올바르면, 웹 서버는 요청에 대한 응답을 보낸다.

### HTTP 기본인증
가장 간단한 인증 방식 중 하나이다.  
클라이언트가 서버에 요청을 보낼 때, 인증 정보를 함께 전송하여 인증을 수행한다.  

#### HTTP 기본 인증 절차
1. 클라이언트가 서버에 요청을 보낸다.
2. 서버는 클라이언트에게 인증이 필요하다는 응답을 보낸다.
3. 클라이언트는 사용자 이름과 비밀번호를 인코딩하여 Authorization 헤더에 포함시켜 요청을 다시 보낸다.
4. 서버는 Authorization 헤더를 확인하여 클라이언트가 인증되었는지 확인한다.
5. 인증이 성공하면, 서버는 요청에 대한 응답을 보낸다.

#### 기본 인증의 보안 결함
사용자 이름과 비밀번호를 Base64로 인코딩하여 전송하기 때문에 보안성이 떨어지는데  
HTTPS와 같은 보안 프로토콜을 사용하여 전송하는 것이 좋다.  
또한, 요청에 대한 인증 정보가 요청 헤더에 포함되기 때문에,  
요청을 복사하여 다른 사람에게 전송하면 해당 정보를 알 수 있다.  


